#### 树状数组

通过二进制来解决：arr[k]=在k-lowbit(k)和k之间的数的和。左开右闭。

求前缀和时：例如1011: arr[1011]+arr[1010]+arr[1000]

更新某个数：例如1011增加了x：arr[1011]+x,arr[1100]+x,arr[10000]+x（迭代+lowbit(pos)）

lowbit(a)=a&(-a)

#### 红黑树

节点是红色或黑色。
根是黑色。
所有叶子都是黑色（叶子是NIL节点）。
每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。

插入：插红节点，然后做各种左旋右旋的调整。

![img](https://pic3.zhimg.com/80/v2-36af4bd9f695551261f547c27ffce862_1440w.webp)

删除：

![img](https://pic4.zhimg.com/80/v2-70fc7a9e4f92536e8e192b182d6b1a07_1440w.webp)
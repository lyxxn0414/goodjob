### MySQL

#### 执行流程

执行一条SQL（例如select）语句的流程

分为server层（负责连接，解析，执行）和存储引擎层（数据的存储和提取）。

所有**内置函数**（如时间，日期，加密，数学等）和跨存储引擎功能（如**视图**，**触发器**）都在server层。

存储引擎还要实现索引数据结构。

![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png)

#### 第一步：连接器

**TCP三次握手**后建立和Mysql连接。

连接会被**保存在连接器中**，之后用户在此连接里的任何操作，都会**基于连接开始时读到的权限**进行权限逻辑的判断。（连接后修改权限，只会在下一次连接时生效）

### 锁

#### 事务隔离级别

脏读：读到未提交数据

不可重复读：事务**最开始**读到的数据和**结束前**的任意时刻读到的同一批数据都是不一致的。（针对update）

幻读：事务最开始查询到的某个条件记录和结束前任意时刻查询某个条件的记录不一致（针对insert）

![img](https://pic4.zhimg.com/80/v2-2e1a7203478165890e2d09f36cb39857_1440w.webp)

mysql：默认隔离级别是可重复读，采用MVCC+next-key lock的方式。

可重复读隔离级是由 MVCC（多版本并发控制）实现的，实现的方式是开始事务后（执行 begin 语句后），在执行第一个查询语句后，会创建一个 Read View，**后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的**，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。

但不能解决**当前读**的问题（非普通select语句）

怎么做：事务开始前做select ... for update，加间隙锁。

#### 乐观锁

如何实现：

1. version记录机制：更新后判断**对应记录的版本号**是否和**操作前的版本号**一致。
2. 时间戳，代替version的作用。

### 和influxdb的区别

时序型数据库：数据以**时间戳为关键索引**，并且往往是**按时间顺序追加**的。

关系型数据库：使用**表格**的形式存储数据，数据以**行和列**的形式出现。通过**键**（如主键、外键）来实现不同表之间的关联。

区别：

1. 查询优化：时序型数据库优化**时间相关**的查找（范围查询，聚合查询等），关系型数据库提供**复杂**的查询能力（包括条件查询，joins，分组和聚合等）
2. 写入性能：时序型数据库优化了针对时间序列数据的追加写入性能，关系型数据库面对大量写入性能不如时序型数据库高。
3. 数据存储方式：时序型数据库按时间顺序存储，很多时序型数据库还会对数据进行时间段的压缩；
   关系型数据库顺序不依赖时间，通常使用B树或类似的数据结构来**索引数据**，以支持**高效的任意查询**。



如果应用主要涉及**时间序列数据**的收集、存储和分析，时序型数据库可能更合适。

如果应用需要**复杂的数据关系管理和高级查询**功能，关系型数据库可能是更好的选择。


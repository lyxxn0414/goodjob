#### 内存管理

##### 虚拟内存

作用：**避免不同进程直接使用相同的物理地址**，引发进程间的内存冲突。

###### 具体作用

1. **防止**不同进程之间产生**内存冲突**
2. 使得进程运行内存**可以超过物理内存的大小**
3. 页表中可以记录物理页的属性信息（如访问权限，是否为空等），更**安全**

由**操作系统**做内存映射，将不同进程的虚拟地址映射到实际的物理地址。

CPU再将虚拟地址通过**MMU**找到实际的物理地址，并通过物理地址访问内存。

![img](https://cdn.xiaolincoding.com//mysql/other/72ab76ba697e470b8ceb14d5fc5688d9.png)



操作系统映射的两种方式：分段，分页。

##### 内存分段

虚拟地址=段选择因子+段偏移量。

一个最简单的分段方式：把程序分成4个段，分别存（栈，堆，数据，代码）

![img](https://cdn.xiaolincoding.com//mysql/other/c5e2ab63e6ee4c8db575f3c7c9c85962.png)

问题1：内存碎片。

准确来说是外部内存碎片（因为分段管理中，分配内存是按照程序的内存需求直接分配的。）

当占内存较小的程序运行结束，就会空闲内存不连续。



问题2：内存交换（swap）效率低

swap:把某段内存先装到**硬盘的swap空间**，再装回内存，就可以减少内存碎片。

**swap是为了减少外部内存碎片的**。但分段的方式**太容易产生内存碎片**，每一次内存交换，我们都需要**把一大段连续的内存数据**写到硬盘上。



##### 内存分页

**分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。

虚拟地址与物理地址之间通过**页表**来映射，页表存在内存中，由MMU读取页表做转换。

![img](https://cdn.xiaolincoding.com//mysql/other/08a8e315fedc4a858060db5cb4a654af.png)

虚拟地址在页表中找不到时引发page fault=》进入内核分配新的物理内存，更新页表-》返回用户空间，继续执行进程。



分页为什么能解决分段的两个问题：

1. 页之间没有空隙，因此**没有外部碎片**（但会有内部碎片）
2. 当内存已满/page fault时，进行swap in/swap out时只有几个页参与，效率较高。

bonus：不需要在一开始就将程序全部装载进内存，可以需要使用时再装载对应页。



虚拟地址=页号+页内偏移

![img](https://cdn.xiaolincoding.com//mysql/other/7884f4d8db4949f7a5bb4bbd0f452609.png)



问题：**页表会变得很大**（每个进程都需要有一份自己的页表）

32位环境下（虚拟地址空间4G）-》100w个页-》4M大小的页表，如果有100个进程：400M.

###### 多级页表

利用**局部性原理**，进程中的虚拟地址大多是连续的。

除了一级页表，其它级可以在需要时再创建。

64位系统：4级页表。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9B%9B%E7%BA%A7%E5%88%86%E9%A1%B5.png)

###### TLB

多级页表会有多次访问内存，寻址效率低的情况。

进一步利用局部性，将最常用的页表项放在CPU芯片的专用Cache——TLB（快表）上。

MMU先找TLB,找不到再找页表。

![img](https://cdn.xiaolincoding.com//mysql/other/a3cdf27646b24614a64cfc5d7ccffa35.png)



##### 段页式

地址=段号+页号+页内偏移。（一级页表的情况下：三次访问内存。）

![img](https://cdn.xiaolincoding.com//mysql/other/8904fb89ae0c49c4b0f2f7b5a0a7b099.png)



##### Linux的内存管理

分页。虚拟地址内部被划分为用户空间和内核空间。

**每个进程的虚拟内存中的内核地址，其实关联的都是相同的物理内存。**（进程切换到内核态后，就可以很方便地访问内核空间内存。）

![img](https://cdn.xiaolincoding.com//mysql/other/3a6cb4e3f27241d3b09b4766bb0b1124-20230309234553726.png)

### malloc

#### 用户空间分布

分为多个段，

栈：包括**局部变量**和**函数调用的上下文**等。栈的大小是固定的，一般是 `8 MB`。

文件映射：**动态库**，**共享内存**等。

堆：动态分配的内存

BSS：未初始化的静态变量和全局变量

数据段：已初始化的静态变量和全局变量

代码段：可执行二进制代码。

![虚拟内存空间划分](https://cdn.xiaolincoding.com/gh/xiaolincoder/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/32%E4%BD%8D%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png)

其中，文件映射和堆是动态分配的。可以用mmap()和malloc()申请。

#### malloc

**不是系统调用**，只是C库里的一个函数。

有两种系统调用方式向操作系统申请内存：

- brk()系统调用，从堆分配，将「堆顶」指针向高地址移动
- mmap()，从文件映射区分配，「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/mmap%E7%94%B3%E8%AF%B7.png)

一般来说会有一个阈值（一般是128K），低于该阈值就调brk()，高于就调mmap()。



**malloc分配的是虚拟内存**，在需要用的时候才会由**操作系统加载数据**到物理内存，可能会触发缺页中断。



对于**brk**：

malloc(1):**会预分配更大的空间作为内存池**。

free()时**并不会立刻归还给操作系统**，（缓存在内存池中，在下一次再malloc()时可以把这一块重新利用）而是等进程结束时再归还。



对于**mmap**：

free时会**直接还给操作系统**。



**为什么不都用mmap？**

1. 每次都要向操作系统申请内存，要**执行系统调用**。上下文切换性能开销大。
2. 由于每次free都会真正释放，第一次使用时虚拟内存时总会**缺页中断**。

**brk等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗**。



**为什么不都用brk()?**

可能会让**实际使用内存持续增加**，会带来**内存泄漏**和**堆内不可用碎片**问题。



#### free

free怎么知道要释放多少内存？

有一个16个字节的内存块头信息，记录内存块的描述信息。

![图片](https://cdn.xiaolincoding.com//mysql/other/cb6e3ce4532ff0a6bfd60fe3e52a806e.png)

### 内存分配和回收

#### 内存分配过程

虚拟内存地址没有对应的物理内存空间=》**缺页中断**。

如果有足够大的物理空间=》分配

否则，内核开始进行**回收内存**的工作。

- **后台内存回收**（kswapd）：在物理内存紧张的时候，会唤醒 kswapd 内核线程来回收内存，这个回收内存的过程**异步**的，不会阻塞进程的执行。
- **直接内存回收**（direct reclaim）：如果后台异步回收跟不上进程内存申请的速度，就会开始直接回收，这个回收内存的过程是**同步**的，会阻塞进程的执行。

如果直接内存回收后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会**触发 OOM （Out of Memory）机制**。

根据算法选择一个占用物理内存较高的进程，然后将其杀死

#### 内存回收

两类内存可以被回收：

- 文件页：可以直接在磁盘找到对应的文件。包括内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Page Cache）。**回收干净页的方式是直接释放内存，回收脏页的方式是先写回磁盘后再释放内存**。
- 匿名页：没有实际的载体，例如堆栈。通过Linux的Swap机制写磁盘的swap区，然后释放内存。

回收都是基于LRU算法。实现是通过两个链表：active和inactive。

#### 性能影响

直接内存回收会阻塞进程，导致CPU使用率飙高；

swap需要磁盘I/O操作，也会影响I/O的性能。

##### 怎么减少文件回收带来的影响

1. 调整文件页和匿名页**回收倾向**：clean的文件页不会触发I/O，因此多回收文件页。
2. **尽早触发 kswapd** 内核线程异步回收内存。增大min_free_kbytes及早触发kswapd。
   但还是要看系统关注什么：如果关注内存使用量则应该适当减少min_free_kbytes.

![img](https://cdn.xiaolincoding.com//mysql/other/166bc9f5b7c545d89f1e36ab8dd772cf.png)

#### NUMA架构下的内存回收

SMP（UMA）：多个CPU处理器**地位平等**，共享一切系统资源。问题：总线压力大，单个CPU的可用带宽变小。

NUMA：非一致性存储访问。一组CPU称为一个node，有自己的独立资源（内存，IO等）。node间通过互联模块总线（QPI）通信。

![SMP 与 NUMA 架构](https://cdn.xiaolincoding.com//mysql/other/feec409868070d8cd79aecad2895b531.png)

NUMA架构服务器回收内存一般有四个选项：

具体选哪种模式，可以通过 /proc/sys/vm/zone_reclaim_mode 来控制。它支持以下几个选项：

- 0 （默认值）：在回收本地内存之前，在其他 Node 寻找空闲内存；
- 1：只回收本地内存；
- 2：只回收本地内存，在本地回收内存时，可以将文件页中的脏页写回硬盘，以回收内存。
- 4：只回收本地内存，在本地回收内存时，可以用 swap 方式回收内存。

一般用0，因为回收内存的危害比访问远端内存大。



#### 只有4GB内存，申请8GB会发生什么

**malloc实际申请的是虚拟内存**

32位操作系统会直接报错。

64位：不读写不会被真正分配到物理内存上，因此不会报错。（但还是会用一点物理内存保存虚拟内存的数据结构，因此不能太大量的申请）

不开swap：会在读写过程中发生OOM

开启swap后：可以申请127T空间（程序本身也需要虚拟地址空间）。

可以正常使用8GB（但如果再大的话可能会出现OOM，因为内存回收后仍然无法满足大小）



### 预读失效和缓存污染问题

#### Linux和Mysql的缓存结构

Linux将常用的文件系统数据缓存在Page Cache中，MySQL将常用数据存在buffer pool中。都起到加速访问的作用。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.png)



![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%86%B2%E6%B1%A0.drawio.png)



#### 预读失效

预读：提前读多个页到缓存中。

预读失效：提前加载的页并没有被访问。

解决：Linux：分active_list和inactive_list，分别做LRU。MYSQL-Innodb：分young区域和old区域。

1. **预读页被加入inactive_list队头**。
2. 淘汰从inactive_list末尾淘汰
3. 当有新的页加入active_list，它的**末尾降级成inactive_list队头**，inactive_list末尾淘汰。

Innodb同理，只是将young&old串起来。



#### 缓存污染

**批量读取数据**时淘汰了所有之前的**活跃数据**，污染整条LRU链表。

例如select * from t where name like "%xl%";执行的其实是全表扫描。

解决：提高进入active_list的门槛。例如**第二次被访问**，才能进入active_list。或者两次访问间隔必须大于某个数才能进入。



### Linux虚拟内存管理

#### fork vfork和clone

fork时，它的**虚拟内存空间以及相关页表**相当于父进程虚拟内存空间的一份**拷贝**，直接从父进程中拷贝到子进程中。但是会用**COW**技术。

COW：多个进程申请同一个资源时，将对应的共享资源标记为**只读**。当有进程修改它时，**触发异常**，异常处理程序将copy的新页框分配给受影响的进程。

COW优势：提高性能。

缺点：写放大。可能本来改一个节点却要写四个节点（沿叶子数据块向上更新到根节点）。



`int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);`   

clone和fork的调用方式很不相同，clone调用需要**传入一个函数**，该函数在子进程中执行。
clone和fork最大不同在于clone**不再复制父进程的栈空间**，而是**自己创建一个新的**。 （void *child_stack,）也就是第二个参数，需要分配栈指针的空间大小，所以它不再是继承或者复制，而是全新的创造。

clone可以让你有**选择性的继承父进程的资源**，你可以和父进程共享一个虚存空间，从而使**创造的是线程**，你也可以不和父进程共享，你甚至可以选择创造出来的进程和父进程不再是父子关系，而是兄弟关系。




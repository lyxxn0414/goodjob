### 进程和线程

#### 进程

##### 进程状态

![进程的三种基本状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/7-%E8%BF%9B%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81.jpg)

大量阻塞状态进程会占用内存，因此需要swap到磁盘上（**挂起**）：

挂起：**进程没有占用实际的物理内存空间的情况**

![七种状态变迁](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

sleep或ctrl+z也会让进程被挂起。（sleep:到期后唤醒）



挂起和阻塞：挂起是一种**主动**行为，恢复也要主动完成，不会释放CPU。

阻塞是**被动**的，是遇到**等待事件或信号量**时出现，需要释放CPU。

（程序调试中的条件中断用的是挂起，到某个条件时挂起）



##### PCB（进程控制块）

**PCB 是进程存在的唯一标识**（和进程共存亡）

包含进程描述信息，资源信息，状态信息等

多进程组织形式：**链表**（就绪队列，阻塞队列，运行队列）

![就绪队列和阻塞队列](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg)

##### 进程控制

###### 创建

1. 申请一块空白PCB
2. 分配运行时所需资源（内存等）
3. 将PCB插入就绪队列

###### 终止

1. 找到对应的PCB
2. 如果在执行，则终止执行，把CPU给其它进程
3. **如果有子进程，将它交由1号进程接管**
4. 释放自己持有的其它资源
5. 从对应队列中删除

###### 阻塞

1. 找到PCB
2. **保护现场**（栈，PC等），停止执行
3. PCB移入阻塞队列

###### 唤醒

1. 从阻塞队列找到PCB
2. 移除阻塞队列
3. 移入就绪队列

##### 进程上下文切换

**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。**

![进程上下文切换](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/13-%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2.jpg)

进程上下文切换：被挂起/CPU重新调度

被挂起的几种情况：sleep,当前内存不足，硬件中断，更高优先级进程到来。。



#### 线程

共享地址空间，代码段，数据，打开的文件描述符等。

但每个线程有**独立的栈和寄存器**



比进程开销小，体现在：

1. 创建，中止快（没那么多复杂的资源分配和释放，没有PCB）
2. 切换开销小（主要是不用切换页表）
3. 线程间通讯不需要进入内核层

##### 线程实现

###### 用户线程

![多对一](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/17-%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

**基于用户态的线程管理库**实现，TCB也在库中，**操作系统无感知**（只能看到PCB），也不会参与线程调度。

**由用户级线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。**

优点：切换很快；TCB在用户态

缺点：1.操作系统不参与调度，若一个线程系统调用被阻塞，则所有线程都无法运行。

2.当一个线程运行时，其余线程无法打断（没有权限打断，只有操作系统有）

3.多线程的进程不会得到更多时间片。



###### 内核线程

一对一。

**内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。**

优点：操作系统调度线程，某个线程系统调用发生阻塞时，不会影响其它线程的执行

缺点：内核维护TCB；线程创建，终止，切换需要系统调用，上下文切换开销大。

##### C++的多线程在操作系统上如何运作

通过pthread_create系统调用创建一个**内核线程**，并分配资源（栈等）

同步和互斥原语（mutex）：依赖操作系统的底层API

### 进程间通信

#### 管道（fifo）

**所谓的管道，就是内核里面的一串缓存**。没有格式限制。**必须先进先出**

匿名管道文件只在内存中，不在文件系统中，是没有实体的。因此只有**存在父子关系的进程才能用**（通过fork传递文件描述符）

命名管道提前创建了一个**类型为管道的设备文件**，可以通过名称获取文件描述符，进行通信。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/5-%E7%AE%A1%E9%81%93-pipe.jpg)



shell中的管道：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/8-%E7%AE%A1%E9%81%93-pipe-shell.jpg)

缺点：效率低。A进程需要等B进程读取后才能返回。

#### 消息队列

发送后即可返回。

**消息队列是保存在内核中的消息链表**，会分成一块一块的数据单元。

缺点：1.通信不及时 2. 需要在内核态和用户态间来回拷贝 3. 不适合大文件传输



#### 共享内存

拿出进程的一块虚拟地址指向同一块物理内存。避免了来回拷贝的问题。



#### 信号量

**信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步**

共享内存带来的问题：可能会修改同一块内存产生冲突。

两种原子操作：

- 一个是 **P 操作**，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
- 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

互斥信号量：初始值为1.确保只有一个进程访问

同步信号量：初始值为0.确保A在B之前执行。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/11-%E4%BF%A1%E5%8F%B7%E9%87%8F-%E5%90%8C%E6%AD%A5.jpg)

##### Linux信号量使用

POSIX信号量分为有名信号量和无名

有名：以**文件**形式存在，通过IPC名称进行同步。

无名：只能用作线程间同步（**依赖于进程的内存空间**，进程终止时消失），除非放在共享内存区（由**内核控制**）

线程间通信用无名信号量更简单。

**POSIX不区分二值信号量和计数信号量**

#### 信号

异常情况的工作模式。

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；
- kill -9立即终止

信号是进程间通信机制中**唯一的异步通信机制**

#### socket

可用于跨主机或同一主机的通信。

### 中断

CPU响应外部/内部事件

硬件中断：外部硬件设备产生的中断（e.x. I/O）

软件中断：指令产生的中断



执行过程细节：

1. 响应中断，执行完当前指令后停止，保存PC,寄存器等上下文信息
2. 查中断向量表（在内存中），找到该中断对应的中断程序
3. 执行中断程序
4. 执行一条特殊指令IRET，恢复之前的环境，继续执行



### 多线程冲突

**临界区（\*critical section\*）：它是访问共享资源的代码片段，一定不能给多线程同时执行。**

**互斥（\*mutualexclusion\*）：保证一个线程在临界区执行时，其他线程应该被阻止进入临界区**

**同步**：**并发进程/线程在一些关键点上可能需要互相等待与互通消息**

锁可以解决互斥，信号量可以解决互斥也可以解决同步。

#### 锁

互斥锁通常用来保证同一时间**只有一个线程**可以访问某个**共享资源**，同步锁用于**协调多个线程之间的执行顺序**（典型的同步锁：信号量，条件变量）

##### 自旋锁

**无锁编程的一种**

通过CPU提供的CAS，**不会发生上下文切换**

CPU中的原子指令testandset(lock,1)。（设置新值，返回旧值）

在旧值为1时**忙等待**。（不会释放CPU）

##### 互斥锁

当未获取到锁时保存TCB，将TCB放入等待队列，**释放CPU**继续调度。

释放锁时取出等待队列队头TCB，调度该线程。

互斥锁**加锁失败后会陷入内核态**，让内核来进行线程切换，因此存在性能开销。

#### 信号量

见上文，操作系统原子地实现了P操作和V操作，在进入临界区前后使用。

一个同步的例子：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/19-%E4%BA%92%E6%96%A5%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0-%E5%90%83%E9%A5%AD%E4%BE%8B%E5%AD%90.jpg)

#### 生产者消费者问题

缓冲区需要二者互斥，且二者之间存在同步关系。

需要三个信号量，分别是：

- 互斥信号量 `mutex`：用于互斥访问缓冲区，初始化值为 1；
- 资源信号量 `fullBuffers`：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
- 资源信号量 `emptyBuffers`：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/21-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.jpg)

#### 哲学家问题

法1：奇数号哲学家先拿左边的，偶数号先拿右边的。

法2：只有左右都没人吃饭，才能吃饭

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/30-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90-%E6%96%B9%E6%A1%88%E5%9B%9B%E7%A4%BA%E4%BE%8B.jpg)

#### 读写者问题

- 「读-读」允许：同一时刻，允许多个读者同时读
- 「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写
- 「写-写」互斥：没有其他写者时，写者才能写

需要一个写者信号量，一个读者计数，一个读者计数的信号量。

读者优先：读者读的时候直接拿走写者的信号量

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/32-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%80%E7%A4%BA%E4%BE%8B.jpg)

写者优先：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/33-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%BA%8C%E7%A4%BA%E4%BE%8B.jpg)

公平调度：

添加一个flag，使得如果有写者到来，则后面的读者需要等待写者写完后再进队列。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E4%BA%92%E6%96%A5%E4%B8%8E%E5%90%8C%E6%AD%A5/34-%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85-%E6%96%B9%E6%A1%88%E4%B8%89%E7%A4%BA%E4%BE%8B.jpg)

#### 单服务器检测心跳问题

可以考虑的问题：

1. 存心跳包的数据结构：哈希表+链表
2. 处理网络I/O的模型：多路复用epoll）
3. 处理心跳任务的分发：多线程+负载均衡
4. 线程绑定CPU
5. 线程的内存分配器



![图片](https://cdn.xiaolincoding.com//mysql/other/b63f3afb0bf1db3811f78a7cae8b16ca.png)

可以把某个工作线程绑定到某个CPU上，调度时不会让**一个线程在不同核心来回切换**（Linux提供的`sched_setaffinity` ),

这样可以增加CPU上L1 cache和L2 cache的命中率。
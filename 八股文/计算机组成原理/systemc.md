### systemc

一种基于 C++ 的建模语言。

模拟思路：

1. 事件驱动。使用**事件驱动**的仿真模型来**模拟硬件的并行性**。最常用的是检测到某个信号发生变化就触发某个事件发生。
2. 模块。**硬件被抽象成模块**，模块可以包含模块，形成层次化设计结构。
3. 通道(chanel)。用于在不同模块间通信，实现特定接口来进行标准化通信。
4. 进程和并发。SC_THREAD，SC_METHOD都是**通过进程形式实现**，可以在模拟时并发执行。

#### SC_THREAD

**定义时创建**，但不一定执行。

在仿真开始前就会创建进程所需的资源。

可以被设计为等待特定的事件：wait()等待某个信号/延迟，阻塞并等待唤醒。

**和sc_method区别**：主要是sc_method不能用wait()，必须是**非阻塞的**。一般用来模拟**组合逻辑**，对某个事件敏感，当有事件到来时立即执行。

sc_method通常用于模拟更复杂的**顺序逻辑和状态机**的场景。或者是需要同步到特定事件（如时钟边沿）

#### 特性

sc_in和sc_out可以是一对一，多对多关系。

##### 一致性视图和避免竞争

所有信号的更新和进程的执行都是由**仿真内核按照严格的顺序管理**的，不需要担心**更新同步**问题，也不需要担心**竞争**问题。

怎么做到的？

1. 事件驱动。仿真内核维护一个事件队列，按顺序地处理到来的事件。
2. **全局仿真时钟**（所有进程可见）。使用一个**离散的时间模型**来推进仿真。仿真时间被分成精确的时间点，所有的信号更新和进程激活都在这些离散的时间点上发生。所有进程看到的信号状态都是**基于同一仿真时间点**的。
3. 写入和读取分离。（写：sc_signal/sc_out，读：sc_in）。写时先记录变化，下一个仿真时间点才会一致更新。


### TCP

TCP 是**面向连接的、可靠的、基于字节流**的传输层通信协议。

面向连接：一对一的。（UDP是一对多的）

可靠的：确保消息一定能够被发送到接收方

基于字节流：消息可能会被操作系统**「分组」**成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是**「有序的」**，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对**「重复」**的 TCP 报文会**自动丢弃**。

#### TCP头格式

**序列号**：在建立连接时由计算机生成的**随机数**作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就**「累加」一次该「数据字节数」的大小**。**用来解决网络包乱序问题。**

**确认应答号**：指**下一次「期望」收到的数据的序列号**，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。**用来解决丢包的问题。**

#### TCP连接

需要达成三个共识：socket(ip+port)，序列号，窗口大小（做流量控制）

#### 和UDP区别

*1. 连接*

- TCP 是面向连接的传输层协议，传输数据前先要建立连接。
- UDP 是不需要连接，即刻传输数据。

*2. 一对一/多对多*

- TCP 是一对一的两点服务，即一条连接只有两个端点。
- UDP 支持一对一、一对多、多对多的交互通信

3. 可靠性
4. *传输方式*

- TCP 是流式传输，没有边界，但保证顺序和可靠。
- UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

*5. 分片不同*

- TCP 的数据大小如果大于 MSS 大小，则会在**传输层进行分片**，目标主机收到后，也同样**在传输层组装 TCP 数据包**，如果中途丢失了一个分片，只需要传输丢失的这个分片。
- UDP 的数据大小如果大于 MTU 大小，则会在 **IP 层进行分片**，目标主机收到后，**在 IP 层组装完数据**，接着再传给传输层。



#### 三次握手

1. 服务端先监听某个端口，处于listen状态
2. 客户端初始化序列号为client_isn，并将SYN设为1，发送给服务端，状态设为syn_sent
3. 服务端将确认应答号置为client_isn+1,初始化序列号为server_isn,ACK和SYN置为1，状态为syc_recv
4. 客户端确认应答号置为server_isn+1，ACK=1，状态为established（**第三次握手可以携带数据**）
5. 服务端收到置为established

#### 在Linux中查看tcp状态

netstat -napt

#### 为什么需要三次握手

1. 三次握手确保双方都有发送和接收的能力

2. 阻止重复历史连接的初始化：如果是两次握手，客户端发送第一次握手后宕机，服务端收到后就能进入established状态，就建立了一个历史连接。

3. 可靠地同步双方序列号

   （4.避免资源浪费。如果只有两次握手，服务端每收到一个SYN都要建立一个连接，如果客户端重复多次，则会造成多个冗余链接。）

#### SYN攻击

把**TCP的半连接队列打满**，让其它客户端无法与服务端建立连接。

如何避免：

- 调大 netdev_max_backlog：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。适当调大这个队列的值。
- 增大 TCP 半连接队列。
- 开启 tcp_syncookies：可以在**不使用 SYN 半连接队列的情况下成功建立连接**。当sync队列满了时，服务端算出一个cookie，放到二次握手的序列号里。收到应答报文时，检查ACK包的合法性。
- 减少 SYN+ACK 重传次数：半连接队列在收不到ACK时会不停重传，大于一定重传次数就会断开连接。

#### 为什么要四次挥手

结合概念：

- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。

#### 为什么要TIME_WAIT=2ML

- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；（留够窗口让数据被丢弃）
- 保证「被动关闭连接」的一方，能被正确的关闭；